#!/usr/bin/perl -w
# ======================================================================================
# check_lsi_raid: Nagios/Icinga plugin to check LSI Raid Controller status
# --------------------------------------------------------------------------------------
# Created as part of a semester project at the University of Applied Sciences Hagenberg
# (http://www.fh-ooe.at/en/hagenberg-campus/)
#
# Copyright (c) 2013:
#   Grubhofer Martin    (s1110239013@students.fh-hagenberg.at)
#   Scheipner Alexander (s1110239032@students.fh-hagenberg.at)
#   Werner Sebastian    (s1110239038@students.fh-hagenberg.at)
#   Georg Schoenberger  (gschoenberger@thomas-krenn.com)
#   Jonas Meurer        (jmeurer@inet.de)
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, see <http://www.gnu.org/licenses/>.
# ======================================================================================
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);

our $VERBOSITY = 0;
our $VERSION = "1.2";
our $NAME = "check_lsi_raid: Nagios/Icinga plugin to check LSI Raid Controller status";
our $C_TEMP_WARNING = 80;
our $C_TEMP_CRITICAL = 90;
our $PD_TEMP_WARNING = 40;
our $PD_TEMP_CRITICAL = 45;
our $BBU_TEMP_WARNING = 50;
our $BBU_TEMP_CRITICAL = 60;
our $CV_TEMP_WARNING = 70;
our $CV_TEMP_CRITICAL = 85;
our ($IGNERR_M, $IGNERR_O, $IGNERR_P, $IGNERR_S) = (0, 0, 0, 0);
our $NOENCLOSURES = 0;
our $CONTROLLER = 0;

use constant {
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
 };

# Header maps to parse logical and physical devices
our @ldmap_a = ('DG/VD','TYPE','State','Access','Consist','Cache','Cac','sCC','Size');
our @pdmap_a = ('EID:Slt','DID','State','DG','Size','Intf','Med','SED','PI','SeSz','Model','Sp');

# Print command line usage to stdout.
sub displayUsage {
	print "Usage: \n";
	print "  [ -h | --help ]
    Display this help page\n";
	print "  [ -v | -vv | -vvv | --verbose ]
    Sets the verbosity level.
    No -v is the normal single line output for Nagios/Icinga, -v is a
    more detailed version but still usable in Nagios. -vv is a
    multiline output for debugging configuration errors or more
    detailed information. -vvv is for plugin problem diagnosis.
    For further information please visit:
        http://nagiosplug.sourceforge.net/developer-guidelines.html#AEN39\n";
	print "  [ -V --version ]
    Displays the plugin and, if available, the version if StorCLI.\n";
	print "  [ -C <num> | --controller <num> ]
    Specifies a controller number, defaults to 0.\n";
	print "  [ -EID <ids> | --enclosure <ids> ]
    Specifies one or more enclosure numbers, per default all enclosures. Takes either
    an integer as additional argument or a commaseperated list,
    e.g. '0,1,2'. With --noenclosures enclosures can be disabled.\n";
	print "  [ -LD <ids> | --logicaldevice <ids>]
    Specifies one or more logical devices, defaults to all. Takes either an
    integer as additional argument or a comma seperated list e.g. '0,1,2'.\n";
	print "  [ -PD <ids> | --physicaldevice <ids> ]
    Specifies one or more physical devices, defaults to all. Takes either an
    integer as additional argument or a comma seperated list e.g. '0,1,2'.\n";
	print "  [ -Tw <temp> | --temperature-warn <temp> ]
    Specifies the RAID controller temperature warning threshold, the default
    threshold is ${C_TEMP_WARNING}C.\n";
	print "  [ -Tc <temp> | --temperature-critical <temp> ]
    Specifies the RAID controller temperature critical threshold, the default
    threshold is ${C_TEMP_CRITICAL}C.\n";
	print "  [ -PDTw <temp> | --physicaldevicetemperature-warn <temp> ]
    Specifies the disk temperature warning threshold, the default threshold
    is ${PD_TEMP_WARNING}C.\n";
	print "  [ -PDTc <temp> | --physicaldevicetemperature-critical <temp> ]
    Specifies the disk temperature critical threshold, the default threshold
    is ${PD_TEMP_CRITICAL}C.\n";
	print "  [ -BBUTw <temp> | --bbutemperature-warning <temp> ]
    Specifies the BBU temperature warning threshold, default threshold 
    is ${BBU_TEMP_WARNING}C.\n";
	print "  [ -BBUTc <temp> | --bbutemperature-critical <temp> ]
    Specifies the BBU temperature critical threshold, default threshold 
    is ${BBU_TEMP_CRITICAL}C.\n";
    print "  [ -CVTw <temp> | --cvtemperature-warning <temp> ]
    Specifies the CV temperature warning threshold, default threshold 
    is ${CV_TEMP_WARNING}C.\n";
    print "  [ -CVTc <temp> | --cvtemperature-critical <temp> ]
    Specifies the CV temperature critical threshold, default threshold 
    is ${CV_TEMP_CRITICAL}C.\n";
	print "  [ -Im <count> | --ignore-media-errors <count> ]
    Specifies the warning threshold for media errors per disk, the default
    threshold is $IGNERR_M.\n";
	print "  [ -Io <count> | --ignore-other-errors <count> ]
    Specifies the warning threshold for media errors per disk, the default
    threshold is $IGNERR_O.\n";
	print "  [ -Ip <count> | --ignore-predictive-fail-count <count> ]
    Specifies the warning threshold for media errors per disk, the default
    threshold is $IGNERR_P.\n";
	print "  [ -Is <count> | --ignore-shield-counter <count> ]
    Specifies the warning threshold for media errors per disk, the default
    threshold is $IGNERR_S.\n";
	print "  [ -p <path> | --path <path>]
    Specifies the path to StorCLI, per default uses the tool 'which' to get 
    the StorCLI path.\n";
	print "  [ -b <0/1> | --BBU <0/1> ]
    Check if a BBU or a CacheVault module is present. One must be present unless
    '-b 0' is defined. This ensures that for a given controller a BBU/CV must be
    present per default.\n";
	print "  [ --noenclosures <0/1> ]
    Specifies if enclosures are present or not. 0 means enclosures are
    present (default), 1 states no enclosures are used (no 'eall' in
    storcli commands).\n"
}

# Displays a short Help text for the user
sub displayHelp {
	print $NAME."\n";
	print "Pulgin version: " . $VERSION ."\n";
	print "Copyright (C) 2013 Thomas-Krenn.AG\n";
	print "Current updates available at
    http://git.thomas-krenn.com/check_lsi_raid.git\n";
	print "This Nagios/Icinga Plugin checks LSI RAID controllers for controller,
physical device, logical device, BBU and CV warnings and errors.\n";
	print "In order for this plugin to work properly you need to add the nagios
user to your sudoers file (or create a new one in /etc/sudoers.d/).\n";
	displayUsage();
	print "Further information about this plugin can be found at:
    http://www.thomas-krenn.com/de/wiki/LSI_RAID_Monitoring_Plugin and
    http://www.thomas-krenn.com/de/wiki/LSI_RAID_Monitoring_Plugin
Please send an email to the tk-monitoring plugin-user mailing list:
    tk-monitoring-plugins-user\@lists.thomas-krenn.com
if you have questions regarding use of this software, to submit patches, or
suggest improvements.\n";
	exit(STATE_OK);
}

# Prints the name anmd the version of check_lsi_raid. If storcli is available,
# the version if it is printed also.
# @param storcli The path to storcli command utility
sub displayVersion {
	my $storcli = shift;
	if(defined($storcli)){
		my @storcliVersion = `$storcli -v`;
		foreach my $line (@storcliVersion){
			if($line =~ /^\s*Storage/) {
				$line =~ s/^\s+|\s+$//g;
				print $line;
			}
		}
		print "\n";
	}
	exit(STATE_OK);
}

# Checks if a storcli call was successfull, i.e. if the line 'Status = Sucess'
# is present in the command output.
# @param output The output of the storcli command as array
# @return 1 on success, 0 if not
sub checkCommandStatus{
	my @output = @{(shift)};
	foreach my $line (@output){
		if($line =~ /^Status/){
			if($line eq "Status = Success\n"){
				return 1;
			}
			else{
				return 0;
			}
		}
	}
}

# Shows the time the controller is using. Can be used to check if the
# controller number is a correct one.
# @param storcli The path to storcli command utility, followed by the controller
# number, e.g. 'storcli64 /c0'.
# @return 1 on success, 0 if not
sub getControllerTime{
	my $storcli = shift;
	my @output = `$storcli show time`;
	return (checkCommandStatus(\@output));
}

#TODO Update doc of method
sub getControllerStatus {
	my $sudo = $_[0];
	my $storcli = $_[1];
	my $controller = $_[2];
	my @temperature_w = @{($_[3])};
	my @temperature_c = @{($_[4])};

	my $command = "$sudo $storcli /c$controller show all";
	my $status = 0; # Return Status
	my $statusMessage = ''; # Return String

	my @output = `$command`;

	if(checkCommandStatus(\@output)) {
		foreach my $line (@output) {
			my $first;
			my $last;
			my $temp;
			my $crit = 0;
			if($line =~ /^([a-zA-Z0-9]*)/) {
				$first = $1;
				if($line =~ /([a-zA-Z0-9]*)$/) {
					$last = $1;
					if($first eq "Controller") {
						if($line =~ /\s+([a-zA-Z0-9]*)/) {
							if($1 eq "Status") {
								if($last ne "OK" && $last ne "Optimal") {
									$status = getExitState($status, STATE_WARNING);
									$statusMessage .= "Ctrl. status not optimal, ";
								}
							}
							elsif($1 eq "must") {
								if($last ne "No") {
									$status = getExitState($status, STATE_CRITICAL);
									$statusMessage .= "Ctrl. needs reboot, ";
								}
							}
							elsif($1 eq "has") {
								if($last ne "No") {
									$status = getExitState($status, STATE_WARNING);
									$statusMessage .= "Ctrl. booted in safe mode, ";
								}
							}
							elsif($1 eq "temperature") {
								$temp = $last;
								if($temperature_w[0] eq "in") {
									if(($temp >= $temperature_w[1]) && ($temp <= $temperature_w[2])) {
										# is in warn range, so also check if in critical error range
										if($temperature_c[0] eq "in") {
											if(($temp >= $temperature_c[1]) && ($temp <= $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "Ctrl. temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "Controller temperature is critical (${temp}C), "; }
											}
										} else {
											if(($temp < $temperature_c[1]) || ($temp > $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "Ctrl. temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "Controller temperature is critical (${temp}C), "; }
											}
										}
										if($crit eq 0) { # only warn if not already given a critical error
											$status = getExitState($status, STATE_WARNING);
											if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. warning, "; }
											if ($VERBOSITY == 1) {$statusMessage .= "Ctrl. temp. warning (${temp}C), "; }
											if ($VERBOSITY >= 2) {$statusMessage .= "Controller temperature warning (${temp}C), "; }
										}
									}
								} else {
									if(($temp < $temperature_w[1]) || ($temp > $temperature_w[2])) {
										# is in warn range, so also check if in critical error range
										if($temperature_c[0] eq "in") {
											if(($temp >= $temperature_c[1]) && ($temp <= $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "Ctrl. temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "Controller temperature is critical (${temp}C), "; }
											}
										} else {
											if(($temp < $temperature_c[1]) || ($temp > $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "Ctrl. temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "Controller temperature is critical (${temp}C), "; }
											}
										}
										if($crit eq 0) { # only warn if not already given a critical error
											$status = getExitState($status, STATE_WARNING);
											if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. warning, "; }
											if ($VERBOSITY == 1) {$statusMessage .= "Ctrl. temp. warning (${temp}C), "; }
											if ($VERBOSITY >= 2) {$statusMessage .= "Controller temperature warning (${temp}C), "; }
										}
									}
								}
							}
						}
					}
					elsif($first eq "ROC") {
						if($line =~ /\s+([a-zA-Z0-9]*)/) {
							if($1 eq "temperature") {
								$temp = $last;
								if($temperature_w[0] eq "in") {
									if(($temp >= $temperature_w[1]) && ($temp <= $temperature_w[2])) {
										# is in warn range, so also check if in critical error range
										if($temperature_c[0] eq "in") {
											if(($temp >= $temperature_c[1]) && ($temp <= $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "ROC temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "ROC temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "ROC temperature is critical (${temp}C), "; }
											}
										} else {
											if(($temp < $temperature_c[1]) || ($temp > $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "ROC temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "ROC temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "ROC temperature is critical (${temp}C), "; }
											}
										}
										if($crit eq 0) { # only warn if not already given a critical error
											$status = getExitState($status, STATE_WARNING);
											if ($VERBOSITY == 0) {$statusMessage .= "ROC temp. warning, "; }
											if ($VERBOSITY == 1) {$statusMessage .= "ROC temp. warning (${temp}C), "; }
											if ($VERBOSITY >= 2) {$statusMessage .= "ROC temperature warning (${temp}C), "; }
										}
									}
								} else {
									if(($temp < $temperature_w[1]) || ($temp > $temperature_w[2])) {
										# is in warn range, so also check if in critical error range
										if($temperature_c[0] eq "in") {
											if(($temp >= $temperature_c[1]) && ($temp <= $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "ROC temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "ROC temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "ROC temperature is critical (${temp}C), "; }
											}
										} else {
											if(($temp < $temperature_c[1]) || ($temp > $temperature_c[2])) {
												# critical error
												$crit = 1;
												$status = getExitState($status, STATE_CRITICAL);
												if ($VERBOSITY == 0) {$statusMessage .= "ROC temp. critical, "; }
												if ($VERBOSITY == 1) {$statusMessage .= "ROC temp. is critical (${temp}C), "; }
												if ($VERBOSITY >= 2) {$statusMessage .= "ROC temperature is critical (${temp}C), "; }
											}
										}
										if($crit eq 0) { # only warn if not already given a critical error
											$status = getExitState($status, STATE_WARNING);
											if ($VERBOSITY == 0) {$statusMessage .= "ROC temp. warning, "; }
											if ($VERBOSITY == 1) {$statusMessage .= "ROC temp. warning (${temp}C), "; }
											if ($VERBOSITY >= 2) {$statusMessage .= "ROC temperature warning (${temp}C), "; }
										}
									}
								}
							}
						}
					}
					elsif($first eq "Memory") {
						if($line =~ /(\s+[a-zA-Z0-9]*)/) {
							if($1 eq "Correctable") {
								if($last ne "0") {
									$status = getExitState($status, STATE_WARNING);
									$statusMessage .= "Memory correctable errors detected, ";
								}
							}
							elsif($1 eq "Uncorrectable") {
								if($last ne "0") {
									$status = getExitState($status, STATE_CRITICAL);
									$statusMessage .= "Memory uncorrectable errors detected, ";
								}
							}
						}
					}
					elsif($first eq "Failed") {
						if($last ne "No") {
							$status = getExitState($status, STATE_WARNING);
							$statusMessage .= "Failed to get lock key on bootup, ";
						}
					}
					#TODO Improve rollback detection
					elsif($first eq "A") {
						if($last ne "No") {
							$status = getExitState($status, STATE_WARNING);
							$statusMessage .= "A rollback operation is in progress, ";
						}
					}
				}
			}
		}
		return ($status, $statusMessage);
	} else {
		print "Invalid StorCLI command! ($command)\n";
		exit(STATE_UNKNOWN);
	}
}

# Checks which logical devices are present for the given controller and parses
# the logical devices to a list of hashes. Each hash represents a logical device
# with its values from the output.
# @param storcli The path to storcli command utility, followed by the controller
# number, e.g. 'storcli64 /c0'.
# @param logDevices If given, a list of desired logical device numbers
# @param action The storcli action to check, 'all' or 'init'
# @return A list of hashes, each hash is one logical device. Check ldmap_a for valid
# hash keys.
sub getLogicalDevices{
	my $storcli = shift;
	my @logDevices = @{(shift)};
	my $action = shift;
	my $command = $storcli;
	if(scalar(@logDevices) == 0) { $command .= "/vall"; }
	elsif(scalar(@logDevices) == 1) { $command .= "/v$logDevices[0]"; }
	else { $command .= "/v".join(",", @logDevices); }
	$command .= " show $action";
	
	my @output = `$command`;
	my @foundDevs;
	if(checkCommandStatus(\@output)) {
		if($action eq "all") {
			my $currBlock;
			foreach my $line(@output){
				my @splittedLine;
				if($line =~ /^\/(c[0-9]*\/v[0-9]*).*/){
					$currBlock = $1;
					next;
				}
				if(defined($currBlock)){
					if($line =~ /^\d+\/\d+\s+\w+\d\s+\w+.*/){
						@splittedLine = map { s/^\s*//; s/\s*$//; $_; } split(/\s+/,$line);
						my %lineValues_h;
						# The current block is the c0/v0 name
						$lineValues_h{'ld'} = $currBlock;
						for(my $i = 0; $i < @ldmap_a; $i++){
								$lineValues_h{$ldmap_a[$i]} = $splittedLine[$i];
							}
						push @foundDevs, \%lineValues_h;
					}
				}
			}
		}
		elsif($action eq "init") {
			foreach my $line(@output){
				$line =~ s/^\s+|\s+$//g;#trim line
				if($line =~ /^([0-9]+)\s+INIT.*$/){
					my $vdNum = 'c'.$CONTROLLER.'/v'.$1;
					if($line !~ /Not in progress/i){
						my %lineValues_h;
						my @vals = split('\s+',$line);
						$lineValues_h{'ld'} = $vdNum;
						$lineValues_h{'init'} = $vals[2];
						push @foundDevs, \%lineValues_h;
					}
				}
			}
		}
	}
	else {
		print "Invalid StorCLI command! ($command)\n";
		exit(STATE_UNKNOWN);
	}
	return \@foundDevs;
}

# Checks the status of the logical devices.
# @param statusLevel_a The status level array, elem 0 is the current status,
# elem 1 the warning sensors, elem 2 the critical sensors, elem 3 the verbose
# information for the sensors.
# @param foundLDs The array of logical devices, created by getLogicalDevices
sub getLDStatus{
	my @statusLevel_a = @{(shift)};
	my @foundLDs = @{(shift)};
	my $status;
	foreach my $LD (@foundLDs){
		if(exists($LD->{'State'})){
			if($LD->{'State'} ne 'Optl'){
				$status = 'Critical';
				push $statusLevel_a[2], $LD->{'ld'}.'_State';
				$statusLevel_a[3]->{$LD->{'ld'}.'_State'} = $LD->{'State'};
			}
		}
		if(exists($LD->{'Consist'})){
			if($LD->{'Consist'} ne 'Yes'){
				$status = 'Warning';
				push $statusLevel_a[1], $LD->{'ld'}.'_Consist';
				$statusLevel_a[3]->{$LD->{'ld'}.'_Consist'} = $LD->{'Consist'};
			}
		}
		if(exists($LD->{'init'})){
			$status = 'Warning';
			push $statusLevel_a[1], $LD->{'ld'}.'_Init';
			$statusLevel_a[3]->{$LD->{'ld'}.'_Init'} = $LD->{'init'};
		}
	}
	if(defined($status)){
		if ($status eq 'Warning'){
			if(${$statusLevel_a[0]} ne 'Critical'){
				${$statusLevel_a[0]} = 'Warning';
			}
		}
		else{
			${$statusLevel_a[0]} = 'Critical';
		}
	}
}

# Checks which physical devices are present for the given controller and parses
# the physical devices to a list of hashes. Each hash represents a physical device
# with its values from the output.
# @param storcli The path to storcli command utility, followed by the controller
# number, e.g. 'storcli64 /c0'.
# @param physDevices If given, a list of desired physical device numbers
# @param action The storcli action to check, 'all', 'initialization' or 'rebuild'
# @return A list of hashes, each hash is one physical device. Check pdmap_a for valid
# hash keys.
sub getPhysicalDevices{
	my $storcli = shift;
	my @enclosures = @{(shift)};
	my @physDevices = @{(shift)};
	my $action = shift;

	my $command = $storcli;
	if(!$NOENCLOSURES){
		if(scalar(@enclosures) == 0) { $command .= "/eall"; }
		elsif(scalar(@enclosures) == 1) { $command .= "/e$enclosures[0]"; }
		else { $command .= "/e".join(",", @enclosures); }
	}
	if(scalar(@physDevices) == 0) { $command .= "/sall"; }
	elsif(scalar(@physDevices) == 1) { $command .= "/s$physDevices[0]"; }
	else { $command .= "/s".join(",", @physDevices); }

	$command .= " show $action";
	my @output = `$command`;
	my @foundDevs;
	if(checkCommandStatus(\@output)) {
		if($action eq "all") {
			my $currBlock;
			my $line_ref;
			foreach my $line(@output){
				my @splittedLine;
				if($line =~ /^Drive \/(c[0-9]*\/e[0-9]*\/s[0-9]*) \:$/){
					$currBlock = $1;
					$line_ref = {};
					next;
				}
				if(defined($currBlock)){
					if($line =~ /^\d+\:\d+\s+\d+\s+\w+\s+\d+.*/){
						@splittedLine = map { s/^\s*//; s/\s*$//; $_; } split(/\s+/,$line);
						# The current block is the c0/e252/s0 name
						$line_ref->{'pd'} = $currBlock;
						my $j = 0;
						for(my $i = 0; $i < @pdmap_a; $i++){
							if($pdmap_a[$i] eq 'Size'){
								my $size = $splittedLine[$j];
								if($splittedLine[$j+1] eq 'GB' || $splittedLine[$j+1] eq 'TB'){
									$size .= ''.$splittedLine[$j+1];
									$j++;
								}
								$line_ref->{$pdmap_a[$i]} = $size;
								$j++;
							}
							elsif($pdmap_a[$i] eq 'Model'){
								my $model = $splittedLine[$j];
								# Model should be the next last element, j starts at 0
								if(($j+2) != scalar(@splittedLine)){
									$model .= ' '.$splittedLine[$j+1];
									$j++;
								}
								$line_ref->{$pdmap_a[$i]} = $model;
								$j++;
							}
							else{
								$line_ref->{$pdmap_a[$i]} = $splittedLine[$j];
								$j++;
							}
						}
					}
					if($line =~ /^(Shield Counter|Media Error Count|Other Error Count|BBM Error Count|Drive Temperature|Predictive Failure Count|S\.M\.A\.R\.T alert flagged by drive)\s\=\s+(.*)$/){
						$line_ref->{$1} = $2;
					}
					# If the last value is parsed, set up for the next device
					if(exists($line_ref->{'S.M.A.R.T alert flagged by drive'})){
						push @foundDevs, $line_ref;
						undef $currBlock;
						undef $line_ref;
					}
				}
			}
		}
		elsif($action eq 'rebuild' || $action eq 'initialization') {
				foreach my $line(@output){
				$line =~ s/^\s+|\s+$//g;#trim line
				if($line =~ /^\/c$CONTROLLER\/.*/){
					if($line !~ /Not in progress/i){
						my %lineValues_h;
						my @vals = split('\s+',$line);
						my $key;
						if($action eq 'rebuild'){ $key = 'rebuild'; }
						if($action eq 'initialization'){ $key = 'init'; }
						$lineValues_h{'pd'} = substr($vals[0], 1);
						$lineValues_h{$key} = $vals[1];
						push @foundDevs, \%lineValues_h;
					}
				}
			}
		}
	}
	return \@foundDevs;
}

# Checks the status of the physical devices.
# @param statusLevel_a The status level array, elem 0 is the current status,
# elem 1 the warning sensors, elem 2 the critical sensors, elem 3 the vebose
# information for the sensors.
# @param foundPDs The array of physical devices, created by getPhysicalDevices
sub getPDStatus{
	my @statusLevel_a = @{(shift)};
	my @foundPDs = @{(shift)};
	my $status;
	foreach my $PD (@foundPDs){
		if(exists($PD->{'State'})){
			if($PD->{'State'} ne 'Onln'){
				$status = 'Critical';
				push $statusLevel_a[2], $PD->{'pd'}.'_State';
				$statusLevel_a[3]->{$PD->{'pd'}.'_State'} = $PD->{'State'};
			}
		}
		if(exists($PD->{'Shield Counter'})){
			if($PD->{'Shield Counter'} > '0'){
				$status = 'Warning';
				push $statusLevel_a[1], $PD->{'pd'}.'_Shield_counter';
				$statusLevel_a[3]->{$PD->{'pd'}.'_Shield_counter'} = $PD->{'Shield Counter'};
			}
		}
		if(exists($PD->{'Media Error Count'})){
			if($PD->{'Media Error Count'} > '0'){
				$status = 'Warning';
				push $statusLevel_a[1], $PD->{'pd'}.'_Media_error_count';
				$statusLevel_a[3]->{$PD->{'pd'}.'_Media_error_count'} = $PD->{'Media Error Count'};
			}
		}
		if(exists($PD->{'Other Error Count'})){
			if($PD->{'Other Error Count'} > '0'){
				$status = 'Warning';
				push $statusLevel_a[1], $PD->{'pd'}.'_Other_error_count';
				$statusLevel_a[3]->{$PD->{'pd'}.'_Other_error_count'} = $PD->{'Other Error Count'};
			}
		}
		if(exists($PD->{'BBM Error Count'})){
			if($PD->{'BBM Error Count'} > '0'){
				$status = 'Warning';
				push $statusLevel_a[1], $PD->{'pd'}.'_BBM_error_count';
				$statusLevel_a[3]->{$PD->{'pd'}.'_BBM_error_count'} = $PD->{'BBM Error Count'};
			}
		}
		if(exists($PD->{'Predictive Failure Count'})){
			if($PD->{'Predictive Failure Count'} > '0'){
				$status = 'Warning';
				push $statusLevel_a[1], $PD->{'pd'}.'_Predictive_failure_count';
				$statusLevel_a[3]->{$PD->{'pd'}.'_Predictive_failure_count'} = $PD->{'Predictive Failure Count'};
			}
		}
		if(exists($PD->{'S.M.A.R.T alert flagged by drive'})){
			if($PD->{'S.M.A.R.T alert flagged by drive'} ne 'No'){
				$status = 'Warning';
				push $statusLevel_a[1], $PD->{'pd'}.'_SMART_flag';
			}
		}
		if(exists($PD->{'Drive Temperature'})){
			my $temp = $PD->{'Drive Temperature'};
			if($temp ne 'N/A'){
				$temp =~ /^([0-9]+)C/;
				if(!(checkThreshs($1, $PD_TEMP_CRITICAL))){
					$status = 'Critical';
					push $statusLevel_a[2], $PD->{'pd'}.'_Drive_temp';
				}
				elsif(!(checkThreshs($1, $PD_TEMP_WARNING))){
					$status = 'Warning';
					push $statusLevel_a[1], $PD->{'pd'}.'_Drive_temp';
				}
				$statusLevel_a[3]->{$PD->{'pd'}.'_Drive_temp'} = $1;
			}
		}
		if(exists($PD->{'init'})){
			$status = 'Warning';
			push $statusLevel_a[1], $PD->{'pd'}.'_Init';
			$statusLevel_a[3]->{$PD->{'pd'}.'_Init'} = $PD->{'init'};
		}
		if(exists($PD->{'rebuild'})){
			$status = 'Warning';
			push $statusLevel_a[1], $PD->{'pd'}.'_Rebuild';
			$statusLevel_a[3]->{$PD->{'pd'}.'_Rebuild'} = $PD->{'rebuild'};
		}
	}
	if(defined($status)){
		if ($status eq 'Warning'){
			if(${$statusLevel_a[0]} ne 'Critical'){
				${$statusLevel_a[0]} = 'Warning';
			}
		}
		else{
			${$statusLevel_a[0]} = 'Critical';
		}
	}
}

# Checks the status of the BBU, parses 'bbu show status' for the given controller.
# @param storcli The path to storcli command utility, followed by the controller
# number, e.g. 'storcli64 /c0'.
# @param statusLevel_a The status level array, elem 0 is the current status,
# elem 1 the warning sensors, elem 2 the critical sensors, elem 3 the verbose
# information for the sensors.
sub getBBUStatus {
	my $storcli = shift;
	my @statusLevel_a = @{(shift)};
	my $command = "$storcli /bbu show status";

	my $status;
	my @output = `$command`;
	if(checkCommandStatus(\@output)) {
		my $currBlock;
		foreach my $line (@output) {
			if($line =~ /^(BBU_Info|BBU_Firmware_Status|GasGaugeStatus)/){
				$currBlock = $1;
				next;
			}
			if(defined($currBlock)){
				$line =~ s/^\s+|\s+$//g;#trim line
				if($currBlock eq 'BBU_Info'){
					if ($line =~ /^Battery State/){
						$line =~ /([a-zA-Z]*)$/;
							if($1 ne 'Optimal'){
								$status = 'Warning';
								push $statusLevel_a[1], 'Battery_state';
								$statusLevel_a[3]->{'Battery_State'} = $1
							}
						}
					elsif ($line =~ /^Temperature/){
						$line =~ /([0-9]+) C$/;
						if(!(checkThreshs($1, $BBU_TEMP_CRITICAL))){
							$status = 'Critical';
							push $statusLevel_a[2], 'Battery_temperature';
						}
						elsif(!(checkThreshs($1, $BBU_TEMP_WARNING))){
							$status = 'Warning';
							push $statusLevel_a[1], 'Battery_temperature';
						}
						$statusLevel_a[3]->{'Battery_temperature'} = $1;
					}
				}
				elsif($currBlock eq 'BBU_Firmware_Status'){
					if($line =~ /^Temperature/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "OK") {
							$status = 'Critical';
							push $statusLevel_a[2],'BBU_firmware_temperature';
							$statusLevel_a[3]->{'BBU_firmware_temperature'} = $1;
						}
					}
					elsif($line =~ /^Voltage/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "OK") {
							$status = 'Warning';
							push $statusLevel_a[1],'BBU_voltage';
							$statusLevel_a[3]->{'BBU_voltage'} = $1;
						}
					}
					elsif($line =~ /^I2C Errors Detected/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Critical';
							push $statusLevel_a[2],'BBU_Firmware_I2C_errors';
							$statusLevel_a[3]->{'BBU_Firmware_I2C_Errors'} = $1;
						}
					}
					elsif($line =~ /^Battery Pack Missing/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Critical';
							push $statusLevel_a[2],'Battery_pack_missing';
							$statusLevel_a[3]->{'Battery_pack_missing'} = $1;
						}
					}
					elsif($line =~ /^Replacement required/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Critical';
							push $statusLevel_a[2],'BBU_replacement_required';
							$statusLevel_a[3]->{'BBU_replacement_required'} = $1;
						}
					}
					elsif($line =~ /^Remaining Capacity Low/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Warning';
							push $statusLevel_a[1],'BBU_remaining_capacity_low';
							$statusLevel_a[3]->{'BBU_remaining_capacity_low'} = $1;
						}
					}
					elsif($line =~ /^Pack is about to fail \& should be replaced/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Critical';
							push $statusLevel_a[2],'BBU_should_be_replaced';
							$statusLevel_a[3]->{'BBU_should_be_replaced'} = $1;
						}
					}
				}
				elsif($currBlock eq 'GasGaugeStatus'){
					if($line =~ /^Fully Discharged/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Critical';
							push $statusLevel_a[2],'BBU_GasGauge_discharged';
							$statusLevel_a[3]->{'BBU_GasGauge_discharged'} = $1;
						}
					}
					elsif($line =~ /^Over Temperature/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Warning';
							push $statusLevel_a[1],'BBU_GasGauge_over_temperature';
							$statusLevel_a[3]->{'BBU_GasGauge_over_temperature'} = $1;
						}
					}
					elsif($line =~ /^Over Charged/){
						$line =~ /([a-zA-Z]*)$/;
						if($1 ne "No") {
							$status = 'Critical';
							push $statusLevel_a[2],'BBU_GasGauge_over_charged';
							$statusLevel_a[3]->{'BBU_GasGauge_over_charged'} = $1;
						}
					}
				}
			}
			if(defined($status)){
				if ($status eq 'Warning'){
					if(${$statusLevel_a[0]} ne 'Critical'){
						${$statusLevel_a[0]} = 'Warning';
					}
				}
				else{
					${$statusLevel_a[0]} = 'Critical';
				}
			}	
		}
	}
	else {
		print "Invalid StorCLI command! ($command)\n";
		exit(STATE_UNKNOWN);
	}
}

# Checks the status of the CV module, parses 'cv show status' for the given
# controller.
# @param storcli The path to storcli command utility, followed by the controller
# number, e.g. 'storcli64 /c0'.
# @param statusLevel_a The status level array, elem 0 is the current status,
# elem 1 the warning sensors, elem 2 the critical sensors, elem 3 the verbose
# information for the sensors.
sub getCVStatus {
	my $storcli = shift;
	my @statusLevel_a = @{(shift)};
	my $command = "$storcli /cv show status";

	my @output = `$command`;
	if(checkCommandStatus(\@output)) {
		my $currBlock;
		foreach my $line (@output) {
			if($line =~ /^(Cachevault_Info|Firmware_Status)/){
				$currBlock = $1;
				next;
			}
			if(defined($currBlock)){
				$line =~ s/^\s+|\s+$//g;#trim line
				if($currBlock eq 'Cachevault_Info' && $line =~ /^State/){
					my @vals = split('\s{2,}',$line);
					if($vals[1] ne "Optimal") {
						if(${$statusLevel_a[0]} ne 'Critical'){
							${$statusLevel_a[0]} = 'Warning';
						}
						push $statusLevel_a[1], 'CacheVault_state';
						$statusLevel_a[3]->{'CacheVault_state'} = $vals[1]
					}
				}
				elsif($currBlock eq 'Firmware_Status' && $line =~ /^Replacement required/){
					$line =~ /([a-zA-Z0-9]*)$/;
					if($1 ne "No") {
						${$statusLevel_a[0]} = 'Critical';
						push $statusLevel_a[2],'CacheVault_replacement_required';
					}
				}
			}
		}
	}
	else {
		print "Invalid StorCLI command! ($command)\n";
		exit(STATE_UNKNOWN);
	}
}

# Checks if wheter BBU or CV is present
# @param storcli The path to storcli command utility, followed by the controller
# number, e.g. 'storcli64 /c0'.
# @return A tuple, e.g. (0,0), where 0 means module is not present, 1 present
sub checkBBUorCVIsPresent{
	my $storcli = shift;
	my ($bbu,$cv);
	my @output = `$storcli /bbu show`;
	if(checkCommandStatus(\@output)){ $bbu = 1; }
	else{ $bbu = 0 };
	@output = `$storcli /cv show`;
	if(checkCommandStatus(\@output)) { $cv = 1; }
	else{ $cv = 0 };
	return ($bbu, $cv);
}

# Checks if a given value is in a specified range, the range must follow the
# nagios development guidelines:
# http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT
# @param value The given value to check the pattern for
# @param pattern The pattern specifying the threshold range, e.g. '10:', '@10:20'
# @return 0 if the value is outside the range, 1 if the value satisfies the range
sub checkThreshs{
	my $value = shift;
	my $pattern = shift;
	if($pattern =~ /(^[0-9]+$)/){
		if($value < 0 || $value > $1){
			return 0;
		}
	}
	elsif($pattern =~ /(^[0-9]+)\:$/){
		if($value < $1){
			return 0;
		}
	}
	elsif($pattern =~ /^\~\:([0-9]+)$/){
		if($value > $1){
			return 0;
		}
	}
	elsif($pattern =~ /^([0-9]+)\:([0-9]+)$/){
		if($value < $1 || $value > $2){
			return 0;
		}
	}
	elsif($pattern =~ /^\@([0-9]+)\:([0-9]+)$/){
		if($value >= $1 and $value <= $2){
			return 0;
		}
	}
	else{
		print "Invalid temperature parameter! ($pattern)\n";
		exit(STATE_UNKNOWN);
	}
	return 1;
}

sub getStatusString{
	my $level = shift;
	my @statusLevel_a = @{(shift)};
	my @sensors_a;
	my $status_str = "";
	if($level eq "Warning"){
		@sensors_a = @{$statusLevel_a[1]};
	}
	if($level eq "Critical"){
		@sensors_a = @{$statusLevel_a[2]};
	}
	if($level eq "Warning" || $level eq "Critical"){
		if(@sensors_a){
			# Print which sensors are Warn or Crit
			foreach my $sensor (@sensors_a){
				$status_str .= "[".$sensor." = ".$level;
				if($VERBOSITY){
					if(exists($statusLevel_a[3]->{$sensor})){
						$status_str .= " (".$statusLevel_a[3]->{$sensor}.")";
					}
				}
				$status_str .= "]";
			}
		}
	}
	return $status_str;
}

MAIN: {
	my ($storcli, $sudo, $noSudo, $version, $exitCode);
	# Create default sensor arrays and push them to status level
	my @statusLevel_a ;
	my $status_str = 'OK';
	my $warnings_a = [];
	my $criticals_a = [];
	my $verboseValues_h = {};
	push @statusLevel_a, \$status_str;
	push @statusLevel_a, $warnings_a;
	push @statusLevel_a, $criticals_a;
	push @statusLevel_a, $verboseValues_h;
	# Per default use a BBU
	my $bbu = 1;
	my @enclosures;
	my @logDevices;
	my @physDevices;
	my $platform = $^O;

	if ( !(GetOptions(
		'h|help' => sub {displayHelp();},
		'v|verbose' => sub {$VERBOSITY = 1 },
		'vv' => sub {$VERBOSITY = 2},
		'vvv' => sub {$VERBOSITY = 3},
		'V|version' => \$version,
		'C|controller=i' => \$CONTROLLER,
		'EID|enclosure=s' => \@enclosures,
		'LD|logicaldevice=s' => \@logDevices,
		'PD|physicaldevice=s' => \@physDevices,
		'Tw|temperature-warn=s' => \$C_TEMP_WARNING,
		'Tc|temperature-critical=s' => \$C_TEMP_CRITICAL,
		'PDTw|physicaldevicetemperature-warn=s' => \$PD_TEMP_WARNING,
		'PDTc|physicaldevicetemperature-critical=s' => \$PD_TEMP_CRITICAL,
		'BBUTw|bbutemperature-warning=s' => \$BBU_TEMP_WARNING,
		'BBUTc|bbutemperature-critical=s' => \$BBU_TEMP_CRITICAL,
		'Im|ignore-media-errors=i' => \$IGNERR_M,
		'Io|ignore-other-errors=i' => \$IGNERR_O,
		'Ip|ignore-predictive-fail-count=i' => \$IGNERR_P,
		'Is|ignore-shield-counter=i' => \$IGNERR_S,
		'p|path=s' => \$storcli,
		'b|BBU=i' => \$bbu,
		'noenclosures=i' => \$NOENCLOSURES,
		'nosudo' => \$noSudo,
	)))	{
		print $NAME . " Version: " . $VERSION ."\n";
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	if(defined($version)){ print $NAME . "\nVersion: ". $VERSION . "\n\n"; }
	# Check storcli tool
	if(!defined($storcli)){
		eval('use File::Which');
		if ($platform eq 'linux'){
			$storcli = which('storcli');
			if(!defined($storcli)){
				$storcli = which('storcli64');
			}
		}
		else{
			$storcli = which('storcli.exe');
			if(!defined($storcli)){
				$storcli = which('storcli64.exe');
			}
		}
	}
	if(!defined($storcli)){
		print "Error: cannot find storcli executable.\n";
		exit(STATE_UNKNOWN);
	}
	if ($platform eq 'linux') {
		if(!defined($noSudo)){
			my $sudo;
			chomp($sudo = `which sudo`);
			if(!defined($sudo)){
				print "Error: cannot find sudo executable.\n";
				exit(STATE_UNKNOWN);
			}
			$storcli = $sudo.' '.$storcli;
		}
	}
	# Print storcli version if available
	if(defined($version)){ displayVersion($storcli) }
	# Prepare storcli command
	$storcli .= " /c$CONTROLLER";
	# Check if the controller number can be used
	if(!getControllerTime($storcli)){
		print "Error: invalid controller number, controller not found!\n";
		exit(STATE_UNKNOWN);
	}
	# Prepare command line arrays
	@enclosures = split(/,/,join(',', @enclosures));
	@logDevices = split(/,/,join(',', @logDevices));
	@physDevices = split(/,/,join(',', @physDevices));
	# Check if the BBU param is correct
	if(($bbu != 1) && ($bbu != 0)) {
		print "Error: invalid BBU/CV parameter, must be 0 or 1!\n";
		exit(STATE_UNKNOWN);
	}
	my ($bbuPresent,$cvPresent) = (0,0);
	if($bbu == 1){
		($bbuPresent,$cvPresent) = checkBBUorCVIsPresent($storcli);
		if($bbuPresent == 0 && $cvPresent == 0){
			$statusLevel_a[0] = 'Critical';
			push $criticals_a, 'BBU/CV_Present'
		}
	}
	if($bbuPresent == 1){getBBUStatus($storcli, \@statusLevel_a); }
	if($cvPresent == 1){ getCVStatus($storcli, \@statusLevel_a); }
	
	my $LDDevicesToCheck = getLogicalDevices($storcli, \@logDevices, 'all');
	my $LDInitToCheck = getLogicalDevices($storcli, \@logDevices, 'init');
	my $PDDevicesToCheck = getPhysicalDevices($storcli, \@enclosures, \@physDevices, 'all');
	my $PDInitToCheck = getPhysicalDevices($storcli, \@enclosures, \@physDevices, 'initialization');
	my $PDRebuildToCheck = getPhysicalDevices($storcli, \@enclosures, \@physDevices, 'rebuild');
	
	getLDStatus(\@statusLevel_a, $LDDevicesToCheck);
	getLDStatus(\@statusLevel_a, $LDInitToCheck);
	getPDStatus(\@statusLevel_a, $PDDevicesToCheck);
	getPDStatus(\@statusLevel_a, $PDInitToCheck);
	getPDStatus(\@statusLevel_a, $PDRebuildToCheck);

	print ${$statusLevel_a[0]}." ";
	print getStatusString("Critical",\@statusLevel_a);
	print getStatusString("Warning",\@statusLevel_a);

	$exitCode = STATE_OK;
	if(${$statusLevel_a[0]} eq "Critical"){
		$exitCode = STATE_CRITICAL;
	}
	if(${$statusLevel_a[0]} eq "Warning"){
		$exitCode = STATE_WARNING;
	}
	exit($exitCode);
}
